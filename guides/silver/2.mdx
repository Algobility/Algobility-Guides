---
title: 'Linear Data Structures'
description: 'Different types of linear data structures and when to use them'
date: '2022-01-01'
credits: Ahmad Bilal
number: 2
---

Data strucutres are different ways to organize data in a computer. You have already seen the most basic data structure in C++, the array. However, there are many other data structures that allow you to store multiple values in different ways. They each have their tradeoffs. Some are faster to search through while others take less space. This guide goes through the most used 'linear' data structures, or the data structures that store data in a 1D sequence.

# Dynamic Arrays (Vectors in C++)

A vector is a powerful data strucutres that automatically adjusts its size based on the number of elements it holds. It's like having an array that can grow or shrink as needed. This flexibility makes vectors incredibly useful for scenarios where the number of elements may change over time.

## Creating Vectors

You can create a vector and initialize it with elements of a specific data type using the following syntax:

```cpp
vector<int> numbers = {1, 2, 3, 4, 5};
```

Here are some alternate methods of creating vectors:

```cpp
vector<int> a;                                       // empty vector of ints
vector<int> b (5, 10);                               // five ints with value 10
vector<int> c (b.begin(),b.end());                   // iterating through second
vector<int> d (c);                                   // copy of c
```

## Adding Elements:

You can add elements to the end of a vector using the `push_back()` function. This function appends a new element to the end of a vector:

```cpp
vector<string> names;
names.push_back("Alice");
names.push_back("Bob");
```

Inserting elements like so is efficient: It usually takes around <Math inline>O(1)</Math> time (More formally, it is said to have an amortized time complexity of <Math inline>O(1)</Math>).

## Accessing Elements:

Accessing elements is similar to arrays using the index notation:

```cpp
vector<int> numbers = {1, 2, 3, 4, 5};
numbers[2] = 99;
cout << "Second number: " << numbers[1] << endl;
```

This operation has a time complexity of <Math inline>O(1)</Math>

## Removing Elements:

Remove elements from the end using the `pop_back() ` function:

```cpp
vector<int> numbers = {1, 2, 3, 4, 5};
names.pop_back();
cout << numbers.size()
```

This is also an <Math inline>O(1)</Math> operation

## Inserting/Deleting Elements at specific positions

To insert an element at a specific position within a vector, you can use the `insert()` function. This function takes two arguments: an iterator pointing to the position where the new element should be inserted and the value of the element to be inserted.

An **iterator** is like a pointer that helps you traverse through the elements of a container. It supports many useful functions and works on almost any standard-library container.

Here's how you can use the `insert()` and `erase()` function to insert an element into the middle of a vector:

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> numbers = {10, 20, 30, 40, 50};
    vector<int>::iterator iter = numbers.begin(); // Create iterater pointing to the first element of numbers
    iter = iter + 2; //When you add a constant to an iterator, the iterator traverses the array. The iterator now points to the third element in the array
    numbers.insert(iter, 25); // Insert 25 at the third position
    numbers.erase(iter+2)   //deletes the element at the fifth position
    return 0;
}
```


## Traversing a Vector with Iterators

While a vector can be traversed just like an array like so:

```cpp
for(int i = 0; i < myVector.size(); i++){
    cout << myVector[i];
}
```

Iterators provide an alternate way to traverse a vector (using the `*` syntax to obtain the value that the iterator is pointing to):

```cpp
for (vector<string>::iterator it = names.begin(); it != names.end(); ++it) {
    cout << *it << " ";
}
```

The reason this is useful is that iterators work with all sorts of containers. As we are about to see, not all containers use the same square-bracket syntax to access elements and in some cases iterators are used by neccessity. However, iterators also make for loops extremely long to write out. C++ offers a handy shorthand for the above code

```cpp
for(const string name: names){
    cout << *name << endl;
}
```

Or to the same effect:

```cpp
for(const string &name: names){
    cout << name << endl;
}
```
